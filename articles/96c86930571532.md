---
title: "関数型プログラミングとは？何が良いの？"
emoji: "🧩"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["関数型プログラミング", "プログラミングパラダイム", "Python"]
published: true
---

## はじめに

最近の実装は関数型プログラミングの考え方を取り入れたものが多いですね。
公式ドキュメントなんか見てても、関数型プログラミングのスタイルでコードを書くことを推奨しているように感じます。

でも、実際に関数型プログラミングって何が良いのでしょうか？
この記事では、関数型プログラミングの基本的な考え方と、その利点について解説します。

## 関数型プログラミングとは？

関数型プログラミングは、プログラムを「関数」の組み合わせとして構築するパラダイムです。

……はい、よくわからないので、具体的に見ていきましょう。

## プログラミングパラダイム

まずは、関数型プログラミングを説明する前に、プログラミングパラダイムについて知っておく必要があります。

プログラミングパラダイムとは、プログラムを書く際の考え方やスタイルのことです。
普段意識する人は少ないかもしれませんが、実はあなたが普段書いているコードも、何らかのパラダイムに基づいています。

代表的なプログラミングパラダイムには以下のようなものがあります。

- 手続き型: 命令の順序に従って処理を行うスタイル。変数の状態を変更しながら進行する。多くのプログラミング言語で採用されている。 C 言語やシェルスクリプトが代表例。
- オブジェクト指向: データとその操作を一つの「オブジェクト」としてまとめ、オブジェクト同士のやり取りで処理を行うスタイル。 Java が代表例。
- 関数型: 入力に対して出力を返す「関数」の組み合わせで処理を行うスタイル。同じ入力に対しては常に同じ出力を返し、副作用を持たない純粋な関数を重視する。 Haskell や Lisp が代表例。

特に、手続き型とオブジェクト指向は、命令文を順番に実行していくスタイルから「命令型プログラミング」と呼ばれることもあります。
また、関数型のように、手続き的にではなく、宣言的に「何をしたいか」を記述するスタイルは「宣言型プログラミング」と総称されます。

近年では、これらのパラダイムを組み合わせたマルチパラダイム言語が主流となっており、 Python もその一つです。

### 手続き型プログラミングの例

手続き型プログラミングでは、変数の状態を変更しながら処理を進めます。例えば、以下のようなコードです。

```python
total = 0

def add(value):
    global total
    total += value

add(5)
add(10)
print(total)  # 出力: 15
```

一行ずつ命令を実行しながら状態を変更していくスタイルですね。

### オブジェクト指向プログラミングの例

オブジェクト指向プログラミングでは、データとその操作を一つの「オブジェクト」としてまとめます。例えば、以下のようなコードです。

```python
class Counter:
    def __init__(self):
        self.total = 0

    def add(self, value):
        self.total += value

counter = Counter()
counter.add(5)
counter.add(10)
print(counter.total)  # 出力: 15
```

一行ずつ実行していくのは手続き型と似ていますが、データと操作が一つのオブジェクトにまとめられている点が特徴ですね。

## 関数型プログラミングの例

それでは、関数型プログラミングではどのように書くのでしょうか？

手続き型・オブジェクト指向では、状態を変更しながら処理を進めていましたが、関数型プログラミングでは、状態を持たずに関数の組み合わせで処理を行います。

```python
def add(x, y):
    return x + y

result = add(5, 10)
print(result)  # 出力: 15
```

:::message
なお、純粋な関数型言語では、状態を持つ変数自体が存在しませんが、 Python はマルチパラダイム言語であり、関数型の考え方を取り入れつつも、状態を持つ変数も使用可能です。
:::

この例では、 `add` 関数は引数として受け取った値を足し合わせて返すだけで、外部の状態を変更したりするなどの副作用を持ちません。

また、同じ入力に対しては常に同じ出力を返します。
例えば、 `add(5, 10)` を何度呼び出しても、常に `15` が返されます。

## 関数型プログラミングのメリット

では、関数型プログラミングのメリットは一体何なのでしょうか？

### 1. 可読性と保守性の向上

関数型プログラミングでは、コードに意味を持たせやすく、関数の役割が明確になります。
そのため、コードの可読性が向上し、保守性も高まります。

例えば、次のようなコードを考えてみましょう。

```python
evens = [] # この時点では evens は空のリスト

# 手続き型スタイルで偶数をリストに追加
for num in range(10):
    if num % 2 == 0:
        evens.append(num)

print(evens) # 出力: [0, 2, 4, 6, 8]
```

このコードは、0から9までの偶数をリストに追加していますが、手続き型のスタイルで書かれています。

`evens = []` で空のリストを最初に宣言し、その後、ループで状態を変更していますが、 `evens` が最初に宣言された時点では、リストの中身は空であり、変数名と実際の中身との乖離が生じています。
そのため、コードの意図を理解するには、以降の処理を追っていく必要があります。

一方、関数型スタイルで同じ処理を書くと、次のようになります。

```python
# 関数型スタイルで偶数をリストに生成（リスト内包表記を使用）
evens = [x for x in range(10) if x % 2 == 0]

print(evens) # 出力: [0, 2, 4, 6, 8]
```

このコードでは、内包表記を使って偶数だけを抽出しています。
`evens` には、最初から最終的な値が直接代入されており、コードの意図が明確です。

### 2. イミュータブルなデータ構造の活用

関数型プログラミングでは、データを変更しないイミュータブル（不変）なデータ構造を活用します。

例えば、先ほどの例の手続き型スタイルでは、リストに要素を追加するために `append` メソッドを使用していましたが、関数型スタイルでは、新しいリストを生成して返す方法を取ります。

```python
def add_element(original_list, element):
    return original_list + [element]

my_list = [1, 2, 3]
new_list = add_element(my_list, 4)
print(my_list)   # 出力: [1, 2, 3]
print(new_list)  # 出力: [1, 2, 3, 4]（my_listとは別のリスト）
```

イミュータブルなデータは、状態の変更によるバグを防ぎ、コードの予測可能性を高めます。

### 3. テスト容易性の向上

関数型プログラミングでは、副作用のない純粋な関数を重視するため、関数の動作が予測しやすくなります。
そのため、ユニットテストが容易になり、バグの発見や修正がしやすくなります。

例えば、次のような純粋な関数を考えてみましょう。

```python
def square(x):
    return x * x
```

この関数は、引数として受け取った値の二乗を返すだけで、外部の状態を変更したりする副作用を持ちません。
そのため、次のように簡単にテストできます。

```python
def test_square():
    assert square(2) == 4
    assert square(-3) == 9
    assert square(0) == 0
```

このように、純粋な関数はテストが容易であり、バグの発見や修正がしやすくなります。

### 4. 並行処理の容易化

関数型プログラミングでは、副作用のない関数を使うため、複数の処理を同時に実行しても問題が起きにくくなります。
そのため、並列処理や分散処理が容易になり、パフォーマンスの向上が期待できます。

例えば、銀行口座からの引き出し処理を考えてみましょう。

```python
import threading
import time

balance = 1000  # 初期残高

def withdraw(amount):
    global balance
    # この3ステップの間にスレッドが切り替わると競合条件が発生
    current = balance        # 1. 残高を読み取り
    time.sleep(0.0001)       # スレッド切り替えをシミュレート
    new_balance = current - amount  # 2. 新しい残高を計算
    balance = new_balance    # 3. 残高を書き込み

# 100円を10回引き出す（合計1000円のはず）
threads = []
for _ in range(10):
    t = threading.Thread(target=withdraw, args=(100,))
    threads.append(t)
    t.start()
for t in threads:
    t.join()

print(f"残高: {balance}円")  # 期待値: 0円、実際: 900円や800円など不定
```

このコードでは、複数のスレッドが同時に `balance` という共有変数を読み取り→計算→書き込みしていますが、この3ステップの間にスレッドが切り替わると、競合条件が発生して残高が正しく計算されません。

一方、関数型スタイルで同じ処理を書くと、次のようになります。

```python
from concurrent.futures import ThreadPoolExecutor

def calculate_balance(current_balance, withdrawals):
    # 純粋な関数：外部状態を変更せず、計算結果を返すだけ
    return current_balance - sum(withdrawals)

balance = 1000
withdrawals = [100] * 10  # 100円を10回引き出し

# 一度に計算（副作用なし）
with ThreadPoolExecutor() as executor:
    future = executor.submit(calculate_balance, balance, withdrawals)
    final_balance = future.result()

print(f"残高: {final_balance}円")  # 確実に 0円
```

このコードでは、 `calculate_balance` 関数は引数として受け取った値から計算結果を返すだけで、外部の状態を変更したりする副作用を持ちません。
そのため、並行処理を行っても競合条件が発生せず、常に正しい結果が得られます。

## 関数型プログラミングのデメリット

関数型プログラミングには多くのメリットがありますが、いくつかのデメリットも存在します。

### 1. 学習コスト

関数型プログラミングの考え方やスタイルは、制約が多いため、慣れるまでに時間がかかることがあります。
特に、状態を持たない純粋な関数を重視するため、手続き型やオブジェクト指向に慣れた人にとっては、最初は理解しづらいかもしれません。

### 2. パフォーマンスの問題

関数型プログラミングでは、状態を持たない純粋な関数を多用するため、関数呼び出しのオーバーヘッドが増えることがあります。
そのため、特に大量のデータを処理する場合やリアルタイム性が求められる場合には、パフォーマンスの問題が発生することがあります。

例えば、次のようなコードを考えてみましょう。

```python
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)
```

このコードは、再帰的に階乗を計算する純粋な関数ですが、大きな値に対してはスタックオーバーフローが発生する可能性があります。
一方、手続き型スタイルで同じ処理を書くと、次のようになります。

```python
def factorial_procedural(n):
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result
```

このコードは、ループを使って階乗を計算するため、スタックオーバーフローの問題は発生しません。

### 3. デバッグの難しさ

関数型プログラミングでは、状態を持たない純粋な関数を多用するため、デバッグが難しくなることがあります。
特に、関数の組み合わせが複雑になると、どの関数が問題を引き起こしているのか特定しづらくなることがあります。
変数を使用できるプログラミング言語の場合は、場合によっては、状態の追跡のために変数を使用した方がデバッグしやすいこともあります。

## 実際に使われている関数型プログラミングの考え方

関数型プログラミングの考え方は、近年よく使われている多くの技術スタックで採用されています。

### Azure Durable Functions

Azure Durable Functions は、サーバーレスアーキテクチャ上で状態を持つワークフローを構築するためのフレームワークです。

Durable Functions では、関数型プログラミングの考え方を取り入れており、状態を持たない純粋な関数を使ってワークフローを定義します。

例えば、タスクを実行する処理（Activity）や、タスクの結果を集約する処理（Orchestrator）などは、すべて関数として定義されます。

以下は、 Azure Durable Functions の公式ドキュメントに掲載されているサンプルコードです。

```python
import azure.functions as func
import azure.durable_functions as df

myApp = df.DFApp(http_auth_level=func.AuthLevel.ANONYMOUS)

# Orchestrator
@myApp.orchestration_trigger(context_name="context")
def hello_orchestrator(context):
    result1 = yield context.call_activity("hello", "Seattle")
    result2 = yield context.call_activity("hello", "Tokyo")
    result3 = yield context.call_activity("hello", "London")

    return [result1, result2, result3]

# Activity
@myApp.activity_trigger(input_name="city")
def hello(city: str):
    return f"Hello {city}"
```

関数型プログラミングの考え方を取り入れることで、Durable Functions は、並列処理や状態管理、エラーハンドリングなどの複雑な処理を簡潔に表現できるようになっています。

### Firebase

Firebase は、 Google が提供するモバイルおよびウェブアプリケーション開発プラットフォームです。

Firebase の SDK の多くは、関数型プログラミングの考え方を取り入れています。

例えば、 Cloud Firestore のデータ操作は、関数型スタイル（関数チェーン）で記述されることが多いです。

以下は、 Cloud Firestore の公式ドキュメントに掲載されているサンプルコードです。

```python
data = {"name": "Los Angeles", "state": "CA", "country": "USA"}

# Add a new doc in collection 'cities' with ID 'LA'
db.collection("cities").document("LA").set(data)
```

関数チェーンを使うことで、一連のデータ操作を簡潔に表現でき、コードの可読性と保守性が向上します。

### フロントエンド

React や Flutter 、 Android の Jetpack Compose 、 iOS の SwiftUI など、近年のフロントエンド開発フレームワークやライブラリは、「宣言型 UI フレームワーク」として設計されており、関数型プログラミングの考え方を取り入れています。

例えば、 SwiftUI では、 UI コンポーネントを関数として定義し、状態の変更に応じて UI を再描画します。

```swift
import SwiftUI

struct AlbumDetail: View {
	var album: Album

	var body: some View {
		List(album.songs) { song in
			HStack {
				Image(album.cover)
				VStack(alignment: .leading) {
					Text(song.title)
					Text(song.artist.name)
						.foregroundStyle(.secondary)
				}
			}
		}
	}
}
```

## まとめ

本記事では、関数型プログラミングの基本的な考え方と、以下の4つの主要なメリットについて解説しました：

1. **可読性と保守性の向上** - コードの意図が明確になり、理解しやすくなる
2. **イミュータブルなデータ構造** - 状態変更によるバグを防ぎ、予測可能性を高める
3. **テスト容易性** - 純粋な関数により、ユニットテストが簡単になる
4. **並行処理の容易化** - 副作用がないため、スレッドセーフな処理が自然に実現できる

一方で、学習コストやパフォーマンスの問題など、いくつかのデメリットも存在します。

重要なのは、 **関数型プログラミングを絶対視するのではなく、適切な場面で活用すること** です。
Python のようなマルチパラダイム言語では、手続き型、オブジェクト指向、関数型の良いところを組み合わせて使うことができます。

実際に、Azure Durable Functions 、 Firebase 、 React 、 SwiftUI などの現代的なフレームワークでは、関数型の考え方が広く採用されています。
これらのツールを使う際には、関数型プログラミングの原則を理解しておくことで、より効果的にコードを書けるようになるでしょう。

## 参考

- [関数型プログラミング HOWTO — Python 3.13.11 ドキュメント](https://docs.python.org/ja/3.13/howto/functional.html)
- [プログラミングパラダイムとは - IT用語辞典 e-Words](https://e-words.jp/w/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%83%91%E3%83%A9%E3%83%80%E3%82%A4%E3%83%A0.html)
- [手続き型言語（命令型言語）とは - IT用語辞典 e-Words](https://e-words.jp/w/%E6%89%8B%E7%B6%9A%E3%81%8D%E5%9E%8B%E8%A8%80%E8%AA%9E.html)
- [オブジェクト指向プログラミング（OOP）とは - IT用語辞典 e-Words](https://e-words.jp/w/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0.html)
- [関数型言語（関数型プログラミング言語）とは - IT用語辞典 e-Words](https://e-words.jp/w/%E9%96%A2%E6%95%B0%E5%9E%8B%E8%A8%80%E8%AA%9E.html)
- [クイック スタート: Python Durable Functions アプリを作成する | Microsoft Learn](https://learn.microsoft.com/ja-jp/azure/azure-functions/durable/quickstart-python-vscode)
- [Cloud Firestore にデータを追加する | Firebase](https://firebase.google.com/docs/firestore/manage-data/add-data?hl=ja#python_6)
- [SwiftUI - Apple Developer](https://developer.apple.com/jp/swiftui/)
